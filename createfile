import React, { useEffect, useRef, useState } from "react";
import {
  TextInput,
  View,
  Text,
  KeyboardAvoidingView,
  ScrollView,
  TouchableOpacity,
} from "react-native";
import styles from "./style";
import {
  EnrichedTextInputInstance,
  EnrichedTextInput,
  OnChangeStateEvent,
} from "react-native-enriched";
import {
  useDeleteMutation,
  useSetMutation,
  useUpdateMutation,
} from "@redux/api/noteApi";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { RootStackParamList } from "src/navigation/types";
import { useNetInfo } from "@react-native-community/netinfo";
import { createTable } from "src/db/createTable";
import { v4 as uuidv4 } from "uuid";
import "react-native-get-random-values";
import { notesTable, SyncStatus } from "src/db/schema";
import Toast from "react-native-toast-message";
import { db } from "src/db/notes";
import { useSelector } from "react-redux";
import { RootState } from "@redux/store";
import { and, eq } from "drizzle-orm";
import {
  Menu,
  MenuOption,
  MenuOptions,
  MenuProvider,
} from "react-native-popup-menu";

type CreateNoteProps = NativeStackScreenProps<RootStackParamList, "CreateNote">;

export default function CreateNote({
  navigation,
  route,
}: Readonly<CreateNoteProps>) {
  const ref = useRef<EnrichedTextInputInstance>(null);
  const [styleState, setStyleState] = useState<OnChangeStateEvent | null>(null);
  const userId = useSelector((state: RootState) => state.auth.token);

  const { isConnected } = useNetInfo();

  const [notes, setNotes] = useState({
    title: "",
    content: "",
    isPasswordProtected: false,
    reminder: null,
  });
  const [isTextEditorVisible, setIsTextEditorVisible] = useState(false);
  const [saveApi] = useSetMutation();
  const [editApi] = useUpdateMutation();
  const [deleteApi] = useDeleteMutation();

  const noteId = route?.params?.id;
  const isEditMode = Boolean(noteId);

  useEffect(() => {
    if (!isEditMode) return;

    setNotes((prev) => ({
      ...prev,
      title: route.params?.title ?? "",
      content: route.params?.content ?? "",
    }));

    ref.current?.setValue?.(route.params?.content ?? "");
  }, [isEditMode]);

  async function handleSave() {
    try {
      const localId = await saveToLocalDB(isConnected ? "synced" : "pending");

      // if (isConnected) {
      if (isEditMode) {
        await editApi({
          id: localId,
          title: notes.title,
          content: notes.content,
          isPasswordProtected: notes.isPasswordProtected,
        }).unwrap();
      } else {
        await saveApi({
          id: localId,
          title: notes.title,
          content: notes.content,
          isPasswordProtected: notes.isPasswordProtected,
        }).unwrap();
      }
      //  }
      //navigation.goBack();
      navigation.replace("Dashboard");
    } catch (error) {
      console.log("Save error:", error);
    }
  }

  async function handleDelete() {
    try {
      if (!noteId) return;
      if (!userId) throw new Error("userID is not correct");
      await db
        .delete(notesTable)
        .where(and(eq(notesTable.id, noteId), eq(notesTable.userId, userId)));

      if (isConnected) {
        await deleteApi({ id: noteId }).unwrap();
      }
      Toast.show({
        text1: "Deleted",
      });
    } catch (error) {
      console.log("Delete error:", error);
    }
    // navigation.goBack();
    navigation.replace("Dashboard");
  }

  async function saveToLocalDB(status: SyncStatus) {
    await createTable();
    if (!userId) {
      throw new Error("userId is required to create a note");
    }

    const id = noteId ?? uuidv4();

    await db
      .insert(notesTable)
      .values({
        id,
        userId,
        title: notes.title,
        content: notes.content,
        updatedAt: new Date().toISOString(),
        isPasswordProtected: notes.isPasswordProtected ? 1 : 0,
        reminder: notes.reminder ?? null,
        syncStatus: status,
      })
      .onConflictDoUpdate({
        target: notesTable.id,
        set: {
          title: notes.title,
          content: notes.content,
          updatedAt: new Date().toISOString(),
          isPasswordProtected: notes.isPasswordProtected ? 1 : 0,
          reminder: notes.reminder,
          syncStatus: status,
        },
      });
    return id;
  }

  return (
    <KeyboardAvoidingView style={styles.all}>
      <View style={styles.container}>
        <View style={styles.upperContainer}>
          <TouchableOpacity style={styles.pressables}>
            <Text style={styles.pressablesText}>Lock</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.pressables}>
            <Text style={styles.pressablesText}>Reminder</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.pressables}>
            <Text style={styles.pressablesText}>AI Summary</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.pressables} onPress={handleSave}>
            <Text style={styles.pressablesText}>Save</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.pressables} onPress={handleDelete}>
            <Text style={styles.pressablesText}>Delete</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.line} />

        <TextInput
          placeholder="Title"
          style={styles.title}
          value={notes.title}
          onChangeText={(value) =>
            setNotes((prev) => ({ ...prev, title: value }))
          }
        />

        <View style={styles.editorContainer}>
          <ScrollView contentContainerStyle={{ height: 550 }}>
            <EnrichedTextInput
              ref={ref}
              onChangeState={(e) => setStyleState(e.nativeEvent)}
              onChangeHtml={(e) => {
                const text = e.nativeEvent.value;
                setNotes((prev) => ({
                  ...prev,
                  content: text,
                }));
              }}
              style={styles.input}
            />
          </ScrollView>
        </View>

        <View style={styles.buttons}>
          <TouchableOpacity
            style={styles.button}
            onPress={() => ref.current?.toggleBold()}
          >
            <Text style={[styles.buttonText, styles.bold]}>B</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.button}
            onPress={() => ref.current?.toggleItalic()}
          >
            <Text style={[styles.italic, styles.buttonText]}>I</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.button}
            onPress={() => ref.current?.toggleUnderline()}
          >
            <Text style={styles.buttonText}>U</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.button}
            onPress={() => ref.current?.toggleOrderedList()}
          >
            <Text style={styles.buttonText}>1</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.button}
            onPress={() => ref.current?.toggleUnorderedList()}
          >
            <Text style={styles.buttonText}>â€¢</Text>
          </TouchableOpacity>
        </View>

       
    </KeyboardAvoidingView>
  );
}
